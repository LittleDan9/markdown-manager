import React, { useEffect, useState, useRef } from "react";
import ReactDOM from "react-dom/client";
import { createPortal } from "react-dom";
import { Modal, Button } from 'react-bootstrap';
import { render } from "@/services/rendering";
import { useTheme, ThemeProvider } from "@/providers/ThemeProvider";
import { useDocumentContext } from "@/providers/DocumentContextProvider.jsx";
import { HighlightService } from "@/services/editor";
import { useMermaid } from "@/services/rendering";
import { useCodeCopy } from "@/hooks/ui/useCodeCopy";
import { useImageMetadata } from "@/services/ImageMetadataService";
import { NotificationProvider } from "./NotificationProvider";
import DiagramControls from "./renderer/DiagramControls";
import UserImage from "./image/UserImage";
import ImageCropOverlay from "./image/ImageCropOverlay";

/**
 * Modern Renderer component using the new useMermaid hook architecture
 *
 * This component renders markdown content with syntax highlighting and Mermaid diagrams
 * using the new modular architecture for better performance and maintainability.
 *
 * Benefits over the legacy approach:
 * - Cleaner state management with React hooks
 * - Automatic loading states and theme management
 * - Better error handling and user feedback
 * - No manual ref management for rendering state
 * - Optimized Mermaid diagram rendering
 */
function Renderer({ content, scrollToLine, fullscreenPreview, onFirstRender, showLoadingOverlay, loadingMessage }) {
  const { theme } = useTheme();
  const { highlightedBlocks, setHighlightedBlocks, previewHTML, setPreviewHTML, currentDocument } = useDocumentContext();
  const { getCropData, updateCropData, extractFilename } = useImageMetadata();
  const [html, setHtml] = useState("");
  const [isRendering, setIsRendering] = useState(false);
  const [showImageModal, setShowImageModal] = useState(false);
  const [selectedImage, setSelectedImage] = useState(null);
  const cropModeRef = useRef(null); // { filename, lineNumber, imageDimensions, currentCrop }
  const [cropOverlayKey, setCropOverlayKey] = useState(0); // Force re-render of crop overlay only
  const previewScrollRef = useRef(null);
  const hasCalledFirstRender = useRef(false);
  const diagramControlsRefs = useRef(new Map()); // For cleanup
  const imageControlsRefs = useRef(new Map()); // For cleanup of image components

  // Setup copy functionality for code blocks
  const setCodeCopyRef = useCodeCopy(previewHTML, true);

  // Use the new Mermaid hook - much cleaner than manual state management!
  const {
    renderDiagrams,
    updateTheme,
    currentTheme: mermaidTheme
  } = useMermaid(theme);

  // Setup global image modal function (fallback for external images)
  useEffect(() => {
    window.openImageModal = (imageElement) => {
      setSelectedImage({
        src: imageElement.src,
        alt: imageElement.alt,
        title: imageElement.title
      });
      setShowImageModal(true);
    };

    return () => {
      delete window.openImageModal;
    };
  }, []);

  // Automatic theme updates - no manual checking needed
  useEffect(() => {
    if (theme !== mermaidTheme) {
      updateTheme(theme);
    }
  }, [theme, mermaidTheme, updateTheme]);

  // Reset render flag when document changes (even if content is the same)
  useEffect(() => {
    hasCalledFirstRender.current = false;
  }, [currentDocument?.id]);

  /**
   * Add diagram controls to rendered Mermaid diagrams
   * Only adds controls to NEW diagrams that don't already have them
   * @param {HTMLElement} previewElement - The preview container element
   */
  const addDiagramControls = (previewElement) => {
    if (!previewElement) return;

    // Find all processed Mermaid diagrams
    const diagrams = previewElement.querySelectorAll('.mermaid[data-processed="true"]');

    diagrams.forEach((diagram, index) => {
      const diagramId = `diagram-${index}`;

      // Skip if controls already added and still in DOM
      const existingControls = diagram.querySelector('.diagram-controls-container');
      if (existingControls && existingControls.isConnected) return;

      // Get diagram source from data attribute
      const encodedSource = diagram.getAttribute('data-mermaid-source') || '';
      const diagramSource = encodedSource ? decodeURIComponent(encodedSource) : '';

      // Add mermaid-container class if not present
      if (!diagram.classList.contains('mermaid-container')) {
        diagram.classList.add('mermaid-container');
      }

      // Remove any orphaned controls first
      const orphanedControls = diagram.querySelectorAll('.diagram-controls-container');
      orphanedControls.forEach(control => control.remove());

      // Create a container for the controls
      const controlsContainer = document.createElement('div');
      controlsContainer.className = 'diagram-controls-container';
      controlsContainer.style.position = 'absolute';
      controlsContainer.style.top = '0';
      controlsContainer.style.left = '0';
      controlsContainer.style.width = '100%';
      controlsContainer.style.height = '100%';
      controlsContainer.style.pointerEvents = 'none'; // Allow clicks to pass through to diagram
      diagram.appendChild(controlsContainer);

      // Create React root and render controls with providers
      const root = ReactDOM.createRoot(controlsContainer);
      root.render(
        <ThemeProvider>
          <DiagramControls
            diagramElement={diagram}
            diagramId={diagramId}
            diagramSource={diagramSource}
          />
        </ThemeProvider>
      );

      // Store the root for cleanup
      diagramControlsRefs.current.set(diagram, root);
    });
  };

  /**
   * Apply crop styles to an image element using clipPath with transform for positioning
   */
  const applyCropStyles = (imgElement, cropData) => {
    if (!cropData) {
      // Remove crop styles
      imgElement.style.removeProperty('clip-path');
      imgElement.style.removeProperty('object-fit');
      imgElement.style.removeProperty('object-position');
      imgElement.style.removeProperty('transform');
      imgElement.style.removeProperty('transform-origin');
      imgElement.removeAttribute('data-has-crop');
      return;
    }

    const { x, y, width, height, unit = 'percentage' } = cropData;

    if (unit === 'percentage') {
      // Clip to show only the desired area
      imgElement.style.setProperty('clip-path', `inset(${y}% ${100 - x - width}% ${100 - y - height}% ${x}%)`, 'important');

      // Scale the image so the cropped area fills the container width
      const scaleX = 100 / width;
      const scaleY = 100 / height;

      // Translate to move the cropped area to the top-left
      const translateX = -(x * scaleX);
      const translateY = -(y * scaleY);

      imgElement.style.setProperty('transform', `scale(${scaleX}, ${scaleY}) translate(${translateX}%, ${translateY}%)`, 'important');
      imgElement.style.setProperty('transform-origin', '0 0', 'important');
      imgElement.style.setProperty('object-fit', 'none', 'important');
      imgElement.setAttribute('data-has-crop', 'true');

      console.log('Applied crop styles with transform:', {
        filename: imgElement.getAttribute('data-filename'),
        cropData,
        transform: imgElement.style.getPropertyValue('transform'),
        clipPath: imgElement.style.getPropertyValue('clip-path')
      });
    }
  };

  /**
   * Add enhanced controls to user images for cropping and expansion
   */
  const addImageControls = (previewElement) => {
    if (!previewElement) return;

    // Find all user images
    const userImages = previewElement.querySelectorAll('img[data-is-user-image="true"]');
    console.log('Found user images:', userImages.length, Array.from(userImages).map(img => ({
      src: img.src,
      filename: img.getAttribute('data-filename'),
      lineNumber: img.getAttribute('data-line-number')
    })));

    userImages.forEach((img, index) => {
      const imageId = `image-${index}`;
      const container = img.closest('.user-image-container');
      if (!container) {
        console.log('No container found for image:', img.src);
        return;
      }

      // Get filename for crop mode check
      const filename = img.getAttribute('data-filename');

      // Skip if this image is currently in crop mode
      if (cropModeRef.current && cropModeRef.current.filename === filename) {
        console.log('Skipping controls for image in crop mode:', filename);
        return;
      }

      // Skip if controls already added and still in DOM
      const existingControls = container.querySelector('.image-hover-controls');
      if (existingControls && existingControls.isConnected) {
        console.log('Controls already exist for:', img.src);
        return;
      }

      // Get image data
      const lineNumber = parseInt(img.getAttribute('data-line-number')) || 1; // Fallback to line 1 if no line number
      const src = img.src;
      const alt = img.alt;
      const title = img.title;

      // Add filename attribute to container for dynamic lookup
      container.setAttribute('data-filename', filename);

      console.log('Processing image:', { filename, lineNumber, src });

      if (!filename) {
        console.log('Missing filename for image:', { filename, lineNumber, src });
        return;
      }

      // Use line number if available, otherwise use 0 as fallback
      const validLineNumber = lineNumber > 0 ? lineNumber : 0;

      // Get crop data for this image instance
      const cropData = getCropData(filename, validLineNumber);
      console.log('Crop data for image:', cropData);

      // Apply crop styles to the image (only if not already applied correctly)
      const currentClipPath = img.style.getPropertyValue('clip-path');
      const hasCorrectCrop = cropData && currentClipPath.includes('inset');

      if (!hasCorrectCrop) {
        applyCropStyles(img, cropData);

        // Debug: Log if crop styles were applied or lost
        if (cropData) {
          console.log('Applied crop styles to image:', filename, {
            clipPath: img.style.clipPath,
            cropData
          });
        }
      } else if (cropData) {
        console.log('Crop styles already correctly applied for:', filename);
      }

      // Remove any orphaned controls first
      const orphanedControls = container.querySelectorAll('.image-controls-container');
      orphanedControls.forEach(control => control.remove());

      // Instead of replacing the image, let's add hover controls
      // Create a simple controls overlay
      const controlsOverlay = document.createElement('div');
      controlsOverlay.className = 'image-hover-controls';
      controlsOverlay.style.position = 'absolute';
      controlsOverlay.style.top = '8px';
      controlsOverlay.style.right = '8px';
      controlsOverlay.style.display = 'none'; // Initially hidden
      controlsOverlay.style.zIndex = '20';
      controlsOverlay.style.background = 'rgba(0, 0, 0, 0.7)';
      controlsOverlay.style.borderRadius = '4px';
      controlsOverlay.style.padding = '4px';
      controlsOverlay.style.gap = '4px';

      // Create buttons with theme-aware styling
      const cropBtn = document.createElement('button');
      cropBtn.className = 'btn btn-sm crop-btn';
      cropBtn.innerHTML = '✂️';
      cropBtn.title = 'Crop image';
      cropBtn.style.width = '24px';
      cropBtn.style.height = '24px';
      cropBtn.style.padding = '0';
      cropBtn.style.fontSize = '12px';
      cropBtn.style.marginRight = '4px';
      cropBtn.style.border = 'none';
      cropBtn.style.borderRadius = '3px';

      const expandBtn = document.createElement('button');
      expandBtn.className = 'btn btn-sm expand-btn';
      expandBtn.innerHTML = '⛶';
      expandBtn.title = 'Expand image';
      expandBtn.style.width = '24px';
      expandBtn.style.height = '24px';
      expandBtn.style.padding = '0';
      expandBtn.style.fontSize = '12px';
      expandBtn.style.border = 'none';
      expandBtn.style.borderRadius = '3px';

      // Apply theme-aware styling
      const applyThemeToButtons = () => {
        const isDark = document.documentElement.getAttribute('data-bs-theme') === 'dark';

        const buttonStyle = {
          background: isDark ? 'rgba(0, 0, 0, 0.7)' : 'rgba(255, 255, 255, 0.9)',
          color: isDark ? 'white' : '#333',
          transition: 'all 0.2s ease'
        };

        Object.assign(cropBtn.style, buttonStyle);
        Object.assign(expandBtn.style, buttonStyle);

        // Update overlay background for theme
        controlsOverlay.style.background = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.7)';
      };

      // Apply initial theme
      applyThemeToButtons();

      // Listen for theme changes
      const themeObserver = new MutationObserver(() => {
        applyThemeToButtons();
      });

      themeObserver.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['data-bs-theme']
      });

      // Add hover effects
      const addHoverEffect = (btn) => {
        btn.addEventListener('mouseenter', () => {
          btn.style.transform = 'scale(1.1)';
          const isDark = document.documentElement.getAttribute('data-bs-theme') === 'dark';
          btn.style.background = isDark ? 'rgba(0, 0, 0, 0.9)' : 'rgba(255, 255, 255, 1)';
        });

        btn.addEventListener('mouseleave', () => {
          btn.style.transform = 'scale(1)';
          applyThemeToButtons();
        });
      };

      addHoverEffect(cropBtn);
      addHoverEffect(expandBtn);

      // Append buttons to overlay
      controlsOverlay.appendChild(cropBtn);
      controlsOverlay.appendChild(expandBtn);

      // Add hover functionality
      container.addEventListener('mouseenter', () => {
        // Don't show hover controls if we're in crop mode for this image
        if (cropModeRef.current && cropModeRef.current.filename === filename) {
          return;
        }
        controlsOverlay.style.display = 'flex';
      });

      container.addEventListener('mouseleave', () => {
        // Don't hide controls if we're in crop mode for this image
        if (cropModeRef.current && cropModeRef.current.filename === filename) {
          return;
        }
        controlsOverlay.style.display = 'none';
      });

      // Add click handlers
      cropBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('Crop button clicked for:', filename);

        // Get image dimensions from the img element
        const imgElement = container.querySelector('img');
        if (imgElement) {
          const imageDimensions = {
            width: imgElement.naturalWidth || imgElement.width,
            height: imgElement.naturalHeight || imgElement.height
          };

          // Get current crop data or use defaults
          const currentCrop = cropData || {
            x: 10,
            y: 10,
            width: 80,
            height: 80,
            unit: 'percentage'
          };

          // Enter crop mode using ref to prevent re-renders
          cropModeRef.current = {
            filename: filename,
            lineNumber: lineNumber, // Include line number for saving
            imageDimensions: imageDimensions,
            currentCrop: currentCrop
          };
          // Force crop overlay to re-render by incrementing key
          console.log('Before setCropOverlayKey - current key:', cropOverlayKey);
          setCropOverlayKey(prev => {
            console.log('setCropOverlayKey: prev =', prev, 'new =', prev + 1);
            return prev + 1;
          });
          console.log('Entered crop mode for:', filename, {
            imageDimensions,
            currentCrop,
            containerHasDataFilename: container.getAttribute('data-filename'),
            lineNumber: lineNumber
          });
        }
      });

      expandBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        console.log('Expand button clicked for:', filename);
        // Handle image expansion
        setSelectedImage({
          src: src,
          alt: alt,
          title: title,
          filename: filename,
          cropData: cropData
        });
        setShowImageModal(true);
      });

      // Add the controls to the container
      container.appendChild(controlsOverlay);

      // Store the controls for cleanup (simpler approach)
      imageControlsRefs.current.set(container, {
        overlay: controlsOverlay,
        observer: themeObserver
      });
    });
  };

  /**
   * Clean up diagram controls that are no longer in the DOM
   * Uses asynchronous cleanup to avoid React race conditions
   */
  const cleanupStaleControls = () => {
    const validDiagrams = new Set();
    const validImages = new Set();

    if (previewScrollRef.current) {
      const currentDiagrams = previewScrollRef.current.querySelectorAll('.mermaid[data-processed="true"]');
      currentDiagrams.forEach(diagram => validDiagrams.add(diagram));

      const currentImageContainers = previewScrollRef.current.querySelectorAll('.user-image-container');
      currentImageContainers.forEach(container => validImages.add(container));
    }

    // Async cleanup to avoid race conditions
    setTimeout(() => {
      // Cleanup diagram controls
      diagramControlsRefs.current.forEach((root, diagram) => {
        if (!validDiagrams.has(diagram)) {
          try {
            root.unmount();
            diagramControlsRefs.current.delete(diagram);
          } catch (error) {
            console.warn('Error unmounting stale diagram controls:', error);
          }
        }
      });

      // Cleanup image controls
      imageControlsRefs.current.forEach((controlsData, container) => {
        if (!validImages.has(container)) {
          try {
            if (controlsData.overlay && controlsData.overlay.parentNode) {
              controlsData.overlay.parentNode.removeChild(controlsData.overlay);
            }
            if (controlsData.observer) {
              controlsData.observer.disconnect();
            }
            imageControlsRefs.current.delete(container);
          } catch (error) {
            console.warn('Error removing stale image controls:', error);
          }
        }
      });
    }, 0);
  };

  // Function to restore controls after modal interactions
  const restoreImageControls = () => {
    setTimeout(() => {
      if (previewScrollRef.current) {
        console.log('Restoring image controls after modal interaction');
        addImageControls(previewScrollRef.current);
      }
    }, 100); // Small delay to ensure DOM has settled
  };

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      // Use async cleanup on unmount to avoid race conditions
      setTimeout(() => {
        // Cleanup diagram controls
        diagramControlsRefs.current.forEach((root, diagram) => {
          try {
            root.unmount();
          } catch (error) {
            console.warn('Error unmounting diagram controls on cleanup:', error);
          }
        });
        diagramControlsRefs.current.clear();

        // Cleanup image controls
        imageControlsRefs.current.forEach((controlsData, container) => {
          try {
            if (controlsData.overlay && controlsData.overlay.parentNode) {
              controlsData.overlay.parentNode.removeChild(controlsData.overlay);
            }
            if (controlsData.observer) {
              controlsData.observer.disconnect();
            }
          } catch (error) {
            console.warn('Error removing image controls on cleanup:', error);
          }
        });
        imageControlsRefs.current.clear();
      }, 0);
    };
  }, []);

  // Render Markdown to HTML (when content changes or component mounts)
  useEffect(() => {
    console.log("=== MARKDOWN RENDER TRIGGERED ===", {
      contentLength: content?.length,
      documentId: currentDocument?.id,
      timestamp: new Date().toISOString(),
      cropMode: cropModeRef.current?.filename
    });

    setIsRendering(true);
    // Reset the first render flag when content changes or document changes
    hasCalledFirstRender.current = false;

    let htmlString = render(content);
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = htmlString;
    const codeBlocks = Array.from(tempDiv.querySelectorAll("[data-syntax-placeholder]"));
    const blocksToHighlight = [];

    codeBlocks.forEach(block => {
      const code = decodeURIComponent(block.dataset.code);
      const language = block.dataset.lang;
      const placeholderId = `syntax-highlight-${HighlightService.hashCode(language + code)}`;
      block.setAttribute("data-syntax-placeholder", placeholderId);

      // Use current highlighted blocks (from closure)
      if (highlightedBlocks[placeholderId]) {
        const codeEl = block.querySelector("code");
        if (codeEl) {
          codeEl.innerHTML = highlightedBlocks[placeholderId];
          block.setAttribute("data-processed", "true");
        }
      } else {
        block.setAttribute("data-processed", "false");
        blocksToHighlight.push({ code, language, placeholderId });
      }
    });

    if (blocksToHighlight.length > 0) {
      HighlightService.highlightBlocks(blocksToHighlight).then(results => {
        // Re-process the HTML with new highlights
        const updatedTempDiv = document.createElement("div");
        updatedTempDiv.innerHTML = render(content);
        const updatedCodeBlocks = Array.from(updatedTempDiv.querySelectorAll("[data-syntax-placeholder]"));

        updatedCodeBlocks.forEach(block => {
          const code = decodeURIComponent(block.dataset.code);
          const language = block.dataset.lang;
          const placeholderId = `syntax-highlight-${HighlightService.hashCode(language + code)}`;
          block.setAttribute("data-syntax-placeholder", placeholderId);

          // Apply both existing and new highlights
          const highlightedHtml = results[placeholderId] || highlightedBlocks[placeholderId];
          if (highlightedHtml) {
            const codeEl = block.querySelector("code");
            if (codeEl) {
              codeEl.innerHTML = highlightedHtml;
              block.setAttribute("data-processed", "true");
            }
          }
        });

        // Update highlighted blocks state with new highlights only
        const newHighlights = {};
        Object.entries(results).forEach(([id, html]) => {
          if (!highlightedBlocks[id]) {
            newHighlights[id] = html;
          }
        });

        if (Object.keys(newHighlights).length > 0) {
          setHighlightedBlocks(prev => ({ ...prev, ...newHighlights }));
        }

        htmlString = updatedTempDiv.innerHTML;
        setHtml(htmlString);
        // isRendering will be handled by Mermaid effect
      }).catch(error => {
        console.error("Syntax highlighting failed:", error);
        htmlString = tempDiv.innerHTML;
        setHtml(htmlString);
        // isRendering will be handled by Mermaid effect
      });
    } else {
      htmlString = tempDiv.innerHTML;
      setHtml(htmlString);
      // isRendering will be handled by Mermaid effect
    }
  }, [content, currentDocument?.id]); // Depend on content AND document ID to handle document changes

  // Handle Mermaid rendering - much cleaner with the hook!
  useEffect(() => {
    if (!html) return;

    const processMermaidDiagrams = async () => {
      // Don't set isRendering here as it's already set by the markdown effect
      if (html.includes("data-mermaid-source")) {
        try {
          const updatedHtml = await renderDiagrams(html, theme);
          console.log('=== SETTING PREVIEW HTML (with Mermaid) ===', {
            cropMode: cropModeRef.current?.filename,
            timestamp: new Date().toISOString()
          });
          setPreviewHTML(updatedHtml);
        } catch (error) {
          console.error("Mermaid rendering failed:", error);
          console.log('=== SETTING PREVIEW HTML (Mermaid failed) ===', {
            cropMode: cropModeRef.current?.filename,
            timestamp: new Date().toISOString()
          });
          setPreviewHTML(html);
        }
      } else {
        console.log('=== SETTING PREVIEW HTML (no Mermaid) ===', {
          cropMode: cropModeRef.current?.filename,
          timestamp: new Date().toISOString()
        });
        setPreviewHTML(html);
      }
      // Always set rendering to false when done (whether Mermaid or not)
      setIsRendering(false);
    };

    processMermaidDiagrams();
  }, [html, theme, renderDiagrams]);

  // Add diagram controls after preview HTML is updated
  useEffect(() => {
    if (previewHTML && previewScrollRef.current && !isRendering) {
      // Clean up stale controls (async to avoid race conditions)
      cleanupStaleControls();

      // Add controls to new diagrams (with small delay to ensure DOM is updated)
      setTimeout(() => {
        if (previewScrollRef.current) {
          addDiagramControls(previewScrollRef.current);
          addImageControls(previewScrollRef.current);
        }
      }, 150); // Increased timeout slightly for better stability
    }
  }, [previewHTML, isRendering]);

  // Scroll to line functionality
  useEffect(() => {
    if (scrollToLine && previewScrollRef.current && !isRendering && previewHTML) {
      // Add a small delay to ensure DOM is fully updated
      const scrollTimeout = setTimeout(() => {
        let el = previewScrollRef.current?.querySelector(`[data-line='${scrollToLine}']`);

        if (!el) {
          // If exact line not found, find the closest line
          const allDataLineElements = previewScrollRef.current?.querySelectorAll('[data-line]');
          const availableLines = Array.from(allDataLineElements || [])
            .map(element => ({
              lineNumber: parseInt(element.getAttribute('data-line')),
              element
            }))
            .filter(item => !isNaN(item.lineNumber))
            .sort((a, b) => a.lineNumber - b.lineNumber);

          if (availableLines.length > 0) {
            // Find the closest line (looking both forward and backward)
            let closestLine = availableLines[0];
            let minDistance = Math.abs(availableLines[0].lineNumber - scrollToLine);

            for (const line of availableLines) {
              const distance = Math.abs(line.lineNumber - scrollToLine);
              if (distance < minDistance) {
                closestLine = line;
                minDistance = distance;
              }
            }

            el = closestLine.element;
            console.log(`Line ${scrollToLine} not found, scrolling to closest line ${closestLine.lineNumber} (distance: ${minDistance})`);
          }
        }

        if (el) {
          console.log('Scrolling to line:', scrollToLine);
          el.scrollIntoView({ behavior: "smooth", block: "center" });
        } else {
          console.log('No elements with data-line attributes found');
        }
      }, 100);

      return () => clearTimeout(scrollTimeout);
    }
  }, [scrollToLine, isRendering, previewHTML]);

  // Call onFirstRender when ready
  useEffect(() => {
    console.log("onFirstRender check:", {
      hasCallback: !!onFirstRender,
      isRendering,
      hasPreviewHTML: !!previewHTML,
      hasCalledBefore: hasCalledFirstRender.current
    });

    if (onFirstRender && !isRendering && previewHTML && !hasCalledFirstRender.current) {
      console.log("Calling onFirstRender");
      hasCalledFirstRender.current = true;
      onFirstRender();
    }
  }, [onFirstRender, isRendering, previewHTML]);

  // Listen for diagram export completion events to ensure controls remain visible
  useEffect(() => {
    const handleExportComplete = (event) => {
      console.log('Diagram export completed:', event.detail);

      // Re-validate diagram controls after export to ensure they remain visible
      if (previewScrollRef.current && !isRendering) {
        setTimeout(() => {
          // Check if controls are still present for all diagrams
          const diagrams = previewScrollRef.current.querySelectorAll('.mermaid[data-processed="true"]');
          let needsRevalidation = false;

          diagrams.forEach((diagram) => {
            const existingControls = diagram.querySelector('.diagram-controls-container');
            if (!existingControls || !existingControls.isConnected) {
              needsRevalidation = true;
            }
          });

          if (needsRevalidation) {
            console.log('Re-adding diagram controls after export');
            addDiagramControls(previewScrollRef.current);
            addImageControls(previewScrollRef.current);
          }
        }, 100); // Small delay to ensure export process is fully complete
      }
    };

    window.addEventListener('diagramExportComplete', handleExportComplete);

    return () => {
      window.removeEventListener('diagramExportComplete', handleExportComplete);
    };
  }, [previewHTML, isRendering]);

  // Restore controls immediately when modal closes
  useEffect(() => {
    if (!showImageModal && previewScrollRef.current) {
      // Modal just closed, restore controls
      restoreImageControls();
    }
  }, [showImageModal]);

  // NOTE: Removed metadata change effect as it was interfering with crop styles
  // Controls are restored in specific callbacks when needed

  return (
    <div id="previewContainer">
      <div id="preview" className="position-relative">
        <div
          className="preview-scroll"
          ref={(element) => {
            previewScrollRef.current = element;
            setCodeCopyRef(element);
          }}
          dangerouslySetInnerHTML={{ __html: previewHTML }}
        />
        {showLoadingOverlay && (
          <div
            className="position-absolute top-0 start-0 w-100 h-100 d-flex justify-content-center align-items-center bg-body bg-opacity-90"
            style={{ zIndex: 10, borderRadius: '0.5rem' }}
          >
            <div className="text-center">
              <div className="spinner-border text-primary mb-3" role="status">
                <span className="visually-hidden">Loading...</span>
              </div>
              <div>
                <small className="text-muted">{loadingMessage || "Loading..."}</small>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Image Modal */}
      <Modal
        show={showImageModal}
        onHide={() => {
          setShowImageModal(false);
          restoreImageControls();
        }}
        size="xl"
        centered
        backdrop="static"
      >
        <Modal.Header closeButton>
          <Modal.Title>
            {selectedImage?.title || selectedImage?.alt || 'Image'}
          </Modal.Title>
        </Modal.Header>
        <Modal.Body className="text-center">
          {selectedImage && (
            <img
              src={selectedImage.src}
              alt={selectedImage.alt}
              className="img-fluid"
              style={{ maxHeight: '70vh', maxWidth: '100%' }}
            />
          )}
        </Modal.Body>
        <Modal.Footer>
          <Button variant="secondary" onClick={() => {
            setShowImageModal(false);
            restoreImageControls();
          }}>
            Close
          </Button>
          {selectedImage && (
            <Button
              variant="primary"
              onClick={() => {
                const link = document.createElement('a');
                link.href = selectedImage.src;
                link.download = selectedImage.alt || 'image';
                link.click();
              }}
            >
              <i className="bi bi-download me-2"></i>
              Download
            </Button>
          )}
        </Modal.Footer>
      </Modal>

      {/* Crop Overlay - Rendered via portal to the specific image container */}
      {cropOverlayKey > 0 && (() => {
        // Use ref instead of state to avoid re-renders
        const cropMode = cropModeRef.current;
        console.log('Crop overlay render check:', {
          cropOverlayKey,
          cropMode: cropMode?.filename
        });

        if (!cropMode) {
          console.log('No crop mode, skipping overlay');
          return null;
        }

        // Find the container for the image in crop mode
        const targetContainer = previewScrollRef.current?.querySelector(`[data-filename="${cropMode.filename}"]`);

        console.log('Target container search:', {
          filename: cropMode.filename,
          targetContainer: !!targetContainer,
          querySelector: `[data-filename="${cropMode.filename}"]`,
          containerStyle: targetContainer?.style?.position,
          containerComputedStyle: targetContainer ? window.getComputedStyle(targetContainer).position : 'N/A'
        });

        if (!targetContainer) {
          console.warn('Could not find container for crop mode:', cropMode.filename);
          // Let's see what containers exist
          const allContainers = previewScrollRef.current?.querySelectorAll('[data-filename]');
          console.log('Available containers:', Array.from(allContainers || []).map(c => c.getAttribute('data-filename')));
          return null;
        }

        // Ensure the container has relative positioning for absolute children
        if (window.getComputedStyle(targetContainer).position === 'static') {
          targetContainer.style.position = 'relative';
          console.log('Set container position to relative');
        }

        // Debug container dimensions
        const containerRect = targetContainer.getBoundingClientRect();
        const containerStyles = window.getComputedStyle(targetContainer);
        const imgElement = targetContainer.querySelector('img');

        console.log('Container dimensions:', {
          width: containerRect.width,
          height: containerRect.height,
          top: containerRect.top,
          left: containerRect.left,
          offsetWidth: targetContainer.offsetWidth,
          offsetHeight: targetContainer.offsetHeight,
          scrollHeight: targetContainer.scrollHeight,
          overflow: containerStyles.overflow,
          overflowX: containerStyles.overflowX,
          overflowY: containerStyles.overflowY,
          zIndex: containerStyles.zIndex,
          hasImage: !!imgElement,
          imageSize: imgElement ? { width: imgElement.offsetWidth, height: imgElement.offsetHeight } : null,
          children: targetContainer.children.length
        });

        // Force container to be able to show overlays
        targetContainer.style.overflow = 'visible';
        targetContainer.style.zIndex = '1';
        console.log('Set container overflow to visible and z-index to 1');

        console.log('Creating crop overlay for:', cropMode.filename);

        // Ensure the container maintains its size during crop mode
        targetContainer.style.minWidth = containerRect.width + 'px';
        targetContainer.style.minHeight = containerRect.height + 'px';

        // Use the already declared containerRect from above
        const overlayComponent = createPortal(
          <div style={{
            position: 'fixed',
            top: containerRect.top + 'px',
            left: containerRect.left + 'px',
            width: containerRect.width + 'px',
            height: containerRect.height + 'px',
            zIndex: 99999,
            pointerEvents: 'auto'
          }}>
            <ImageCropOverlay
              key={cropOverlayKey}
              imageDimensions={cropMode.imageDimensions}
              currentCrop={cropMode.currentCrop}
              onCropChange={(newCrop) => {
                console.log('Crop changed:', newCrop);
                cropModeRef.current = {
                  ...cropModeRef.current,
                  currentCrop: newCrop
                };
              }}
              onSave={async (finalCrop) => {
                try {
                  await updateCropData(cropMode.filename, cropMode.lineNumber, finalCrop);
                  console.log('Crop saved for:', cropMode.filename);

                  // Apply crop styles immediately to the saved image
                  const savedImg = targetContainer.querySelector('img[data-filename="' + cropMode.filename + '"]');
                  if (savedImg) {
                    applyCropStyles(savedImg, finalCrop);
                  }

                  cropModeRef.current = null;
                  setCropOverlayKey(0);
                  // Restore container size constraints
                  targetContainer.style.minWidth = '';
                  targetContainer.style.minHeight = '';
                  // Controls will be restored naturally when user hovers or when modal closes
                } catch (error) {
                  console.error('Error saving crop:', error);
                }
              }}
              onCancel={() => {
                console.log('Crop cancelled');
                cropModeRef.current = null;
                setCropOverlayKey(0);
                // Restore container size constraints
                targetContainer.style.minWidth = '';
                targetContainer.style.minHeight = '';
                // Restore image controls after cancel
                setTimeout(() => {
                  if (previewScrollRef.current) {
                    console.log('Restoring image controls after crop cancel');
                    addImageControls(previewScrollRef.current);
                  }
                }, 100);
              }}
            />
          </div>,
          document.body
        );
        console.log('Crop overlay portal created with ImageCropOverlay:', overlayComponent);
        return overlayComponent;
      })()}
    </div>
  );
}

export default Renderer;
